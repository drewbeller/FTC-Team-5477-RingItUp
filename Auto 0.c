#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     LightLeft,      sensorLightActive)
#pragma config(Sensor, S3,     LightRight,     sensorLightActive)
#pragma config(Sensor, S4,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorY,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorT,        tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include<JoystickDriver.c>

int Temp1 = 0;
int Chc0 = 0, Chc2 = 0, Chc3 = 0, Chc4 = 0;
float Chc1 = 0;

void MotorEncoderTarget (int vform, int vleft, int vright, int vpower , int vtime)
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	switch (vform)
	{
		case 1:
			nMotorEncoderTarget[motorL] = vleft;
			nMotorEncoderTarget[motorR] = vright;
			break;
		case 2:
			nMotorEncoderTarget[motorL] = vleft * 115;
			nMotorEncoderTarget[motorR] = vright * 115;
			break;
	}

	if (vleft > 0)
		motor[motorL] = vpower;
	else
		motor[motorL] = -vpower;
	if (vright > 0)
		motor[motorR] = vpower;
	else
		motor[motorR] = -vpower;

	while (nMotorRunState[motorL] != runStateIdle || nMotorRunState[motorR] != runStateIdle)
	{
		nxtDisplayCenteredTextLine(3, "%d", nMotorEncoder[motorL]);
		nxtDisplayCenteredTextLine(4, "%d", nMotorEncoder[motorR]);
		nxtDisplayCenteredTextLine(5, "%d", SensorValue[IRSeeker]);
	}

	motor[motorL] = 0;
	motor[motorR] = 0;
	wait10Msec(vtime);

}

void MoveLift (int vdir, int vdist, int vpower)
{
	switch (vdir)
	{
		case 0:
			break;
		case 1: // Y up
			nMotorEncoder[motorY] = 0;
			nMotorEncoderTarget[motorY] = vdist;
			motor[motorY] = vpower;
			while(nMotorRunState[motorY] != runStateIdle)
				{}
			motor[motorY] = 0;
			break;
		case 2: // Y down
			nMotorEncoder[motorY] = 0;
			nMotorEncoderTarget[motorY] = -vdist;
			motor[motorY] = -vpower;
			while(nMotorRunState[motorY] != runStateIdle)
				{}
			motor[motorY] = 0;
			break;
		case 3: // X up
			break;
		case 4: // X down
			break;
		case 5: // T up
			motor[motorT] = vpower;
			wait1Msec(vdist);
			motor[motorT] = 0;
			break;
		case 6: // T down
			motor[motorT] = -vpower;
			wait1Msec(vdist);
			motor[motorT] = 0;
			break;
	}

	wait10Msec(100);

}

void LineCheck(int vdist)
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	switch(Temp1)
	{
		case 0:
			while (SensorValue[LightLeft] < 40 && (nMotorEncoder[motorL] <= 1000))
			{
				motor[motorL] = 30;
				motor[motorR] = -30;
			}
				motor[motorL] = 0;
				motor[motorR] = 0;
			if(SensorValue[LightLeft] >= 40)
			{
				break;
			}
			while (SensorValue[LightRight] < 40 && (nMotorEncoder[motorR] <= 1000))
			{
				motor[motorL] = -30;
				motor[motorR] = 30;
			}
				motor[motorL] = 0;
				motor[motorR] = 0;
			break;
		case 1:
			while (SensorValue[LightLeft] < 40 && (nMotorEncoder[motorL] <= 1000))
			{
				motor[motorL] = 30;
				motor[motorR] = -30;
			}
				motor[motorL] = 0;
				motor[motorR] = 0;
			if(SensorValue[LightLeft] >= 40)
			{
				break;
			}
			while (SensorValue[LightRight] < 40 && (nMotorEncoder[motorR] <= 1000))
			{
				motor[motorL] = -30;
				motor[motorR] = 30;
			}
				motor[motorL] = 0;
				motor[motorR] = 0;
			break;
		case 2:
			while (SensorValue[LightRight] < 40 && (nMotorEncoder[motorR] <= 1000))
			{
				motor[motorL] = -30;
				motor[motorR] = 30;
			}
				motor[motorL] = 0;
				motor[motorR] = 0;
			if(SensorValue[LightRight] >= 40)
			{
				break;
			}
			while (SensorValue[LightLeft] < 40 && (nMotorEncoder[motorL] <= 1000))
			{
				motor[motorL] = 30;
				motor[motorR] = -30;
			}
				motor[motorL] = 0;
				motor[motorR] = 0;
			break;
	}


	motor[motorL] = 0;
	motor[motorR] = 0;

	wait1Msec(100);

	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;

	while(nMotorEncoder[motorL] +	nMotorEncoder[motorR] <= vdist * 2)
   {
      if(SensorValue[LightLeft] >= 40)  // If the Light Sensor reads a value less than 45:
      {
        motor[motorL] = 5;                  // Motor B is run at a 60 power level.
				motor[motorR] = 40;                  // Motor C is run at a 20 power level.
      }
      else                               // If the Light Sensor reads a value greater than or equal to 45:
      {
      	if (SensorValue[LightRight] >= 40)
      	{
        	motor[motorL] = 40;                  // Motor B is run at a 20 power level.
					motor[motorR] = 5;   							// Motor C is run at a 60 power level.
				}
				else //commented out b/c it would go straight even if the line isn't found
				{
					motor[motorL] = 30;
					motor[motorR] = 30;
				}
      }
   }
}



task main()
{
	nNxtExitClicks = 3;

	while (Chc0 < 7)
	{
		nxtDisplayClearTextLine(1);
		nxtDisplayClearTextLine(2);
		nxtDisplayClearTextLine(3);
		nxtDisplayClearTextLine(4);
		nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
		switch (Chc0)
		{
			case 0:
				nNxtExitClicks = Chc0 + 2;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Wait time (10)");
					nxtDisplayCenteredTextLine(3, "%4.2f", Chc1);
					if (nNxtButtonPressed == 1)
					{
						Chc1 = Chc1 + 10;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 2)
					{
						Chc1 = Chc1 - 10;
						wait10Msec(30);
					}
				}
				wait10Msec(50);
				Chc0++;
				break;
			case 1:
				nNxtExitClicks = Chc0 + 2;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Wait time (1)");
					nxtDisplayCenteredTextLine(3, "%4.2f", Chc1);
					if (nNxtButtonPressed == 1)
					{
						Chc1++;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 2)
					{
						Chc1--;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 0)
					{
						Chc0 = Chc0 - 2;
						break;
					}
				}
				wait10Msec(50);
				Chc0++;
				break;
			case 2:
				nNxtExitClicks = Chc0 + 2;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Wait time (0.1)");
					nxtDisplayCenteredTextLine(3, "%4.2f", Chc1);
					if (nNxtButtonPressed == 1)
					{
						Chc1 = Chc1 + 0.1;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 2)
					{
						Chc1 = Chc1 - 0.1;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 0)
					{
						Chc0 = Chc0 - 2;
						break;
					}
				}
				wait10Msec(50);
				Chc0++;
				break;
			case 3:
				nNxtExitClicks = Chc0 + 2;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Peg Location");
					nxtDisplayCenteredTextLine(3, "%d", Chc2);
					nxtDisplayCenteredTextLine(4, "0 for auto");
					if (nNxtButtonPressed == 1)
					{
						Chc2++;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 2)
					{
						Chc2--;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 0)
					{
						Chc0 = Chc0 - 2;
						break;
					}
				}
				wait10Msec(50);
				Chc0++;
				break;
			case 4:
				nNxtExitClicks = Chc0 + 2;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Movement");
					nxtDisplayCenteredTextLine(3, "%d", Chc3);
					nxtDisplayCenteredTextLine(4, "1:Fwd / 2:Bwd");
					if (nNxtButtonPressed == 1)
					{
						Chc3++;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 2)
					{
						Chc3--;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 0)
					{
						Chc0 = Chc0 - 2;
						break;
					}
				}
				wait10Msec(50);
				Chc0++;
				break;
			case 5:
				nNxtExitClicks = Chc0 + 2;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Side");
					nxtDisplayCenteredTextLine(3, "%d", Chc4);
					nxtDisplayCenteredTextLine(4, "1:Blue / 2:Red");
					if (nNxtButtonPressed == 1)
					{
						Chc4++;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 2)
					{
						Chc4--;
						wait10Msec(30);
					}
					if (nNxtButtonPressed == 0)
					{
						Chc0 = Chc0 - 2;
						break;
					}
				}
				wait10Msec(50);
				Chc0++;
				break;
			case 6:
				nNxtExitClicks = Chc0 + 1;
				while(nNxtButtonPressed != 3)
				{
					nxtDisplayCenteredTextLine(1, "Step %d of 7", Chc0 + 1);
					nxtDisplayCenteredTextLine(2, "Confirm?");
					nxtDisplayCenteredTextLine(3, "%4.2f,%d,%d,%d", Chc1, Chc2, Chc3, Chc4);
					if (nNxtButtonPressed == 0)
					{
						Chc0 = Chc0 - 2;
						break;
					}
				}
				wait10Msec(30);
				Chc0++;
				break;
		}
	}

	nNxtExitClicks = 2;

	nxtDisplayCenteredTextLine(2, "%4.2f,%d,%d,%d", Chc1, Chc2, Chc3, Chc4);

	waitForStart();

	wait10Msec(Chc1 * 100);

	switch(Chc4)
	{
		case 1:
			MotorEncoderTarget(2, 11, 11, 65, 10);

			if (SensorValue[IRSeeker] > 2)
			{
				MotorEncoderTarget(2, 20, 20, 65, 10);
				Temp1++;

				if (SensorValue[IRSeeker] > 2)
				{
					MotorEncoderTarget(2, 21, 21, 65, 10);
					Temp1++;
				}
			}
			wait10Msec(20);
			MotorEncoderTarget(1, -2100, 2100, 60, 30);
			break;
		case 2:
			MotorEncoderTarget(2, 15, 15, 75, 10);

			if (SensorValue[IRSeeker] < 9)
			{
				MotorEncoderTarget(2, 20.5, 20.5, 75, 10);
				Temp1++;

				if (SensorValue[IRSeeker] < 8)
				{
					MotorEncoderTarget(2, 20.5, 20.5, 75, 10);
					Temp1++;
				}
			}
		wait10Msec(20);
		MotorEncoderTarget(1, 2100, -2100, 60, 30);
		break;
	}

	switch(Chc2)
	{
		case 1:
			MoveLift(1, 600, 30);
			break;
		case 2:
			MoveLift(1, 3000, 30);
			break;
		default:
			if(Temp1 == 1)
			{
				MoveLift(1, 3000, 30);
			}
			else
			{
				MoveLift(1, 600, 30);
			}
			break;
	}

	switch (Chc4)
	{
		case 1:
			MotorEncoderTarget(2, 30, 30, 70, 30);
			break;
		case 2:
			MotorEncoderTarget(2, 28, 28, 70, 30);
			break;
	}

	LineCheck(7 * 115);
	motor[motorL] = 0;
	motor[motorR] = 0;

	switch(Chc2)
	{
		case 1:
			MoveLift(2, 530, 30);
			break;
		case 2:
			MoveLift(2, 1200, 30);
			break;
		default:
			if(Temp1 == 1)
			{
				MoveLift(2, 1200, 30);
			}
			else
			{
				MoveLift(2, 530, 30);
			}
			break;
	}

	MotorEncoderTarget(2, -39, -39, 80, 10);

	switch(Chc3)
	{
		case 1:
			switch(Chc4)
			{
				case 1:
					MotorEncoderTarget(1, -2100, 2100, 80, 10);
					break;
				case 2:
					MotorEncoderTarget(1, 2100, -2100, 80, 10);
					break;
			}
			switch (Temp1)
			{
				case 0:
					MotorEncoderTarget(2, 10, 10, 80, 10);
					break;
				case 1:
					MotorEncoderTarget(2, 30, 30, 80, 10);
					break;
				case 2:
					MotorEncoderTarget(2, 50, 50, 80, 10);
					break;
			}
			break;
		case 2:
			switch(Chc4)
			{
				case 1:
					MotorEncoderTarget(1, 2100, -2100, 80, 10);
					break;
				case 2:
					MotorEncoderTarget(1, -2100, 2100, 80, 10);
					break;
			}
			switch (Temp1)
			{
				case 0:
					MotorEncoderTarget(2, -10, -10, 80, 10);
					break;
				case 1:
					MotorEncoderTarget(2, -30, -30, 80, 10);
					break;
				case 2:
					MotorEncoderTarget(2, -50, -50, 80, 10);
					break;
			}
			break;
	}
}
